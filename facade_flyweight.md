# **Паттерн Фасад (Facade Pattern):**
## Упражнение
Представьте, что вы работаете над сложным приложением для редактирования изображений. Это приложение имеет множество функций, таких как применение фильтров, изменение размера изображения, регулировка яркости и контрастности, а также добавление текстовых наложений. Однако для нового пользователя взаимодействие со всеми этими функциями по отдельности может быть затруднительным.

**Задача:** Разработать класс Facade, который упростит взаимодействие пользователя с функциями редактирования изображений.

**Решение:**

1. **Определение подсистем:** Подсистемами в данном случае являются различные функции, такие как фильтры, изменение размера, яркость/контрастность и текстовые наложения. Каждая функция может быть реализована отдельным классом.
2. **Класс Facade:** Создайте класс `ImageEditorFacade`. Этот класс предоставит упрощенный интерфейс для взаимодействия пользователей с функциями редактирования изображений.
3. **Методы Facade:** Реализуйте методы внутри класса `ImageEditorFacade`, которые инкапсулируют функциональность базовых подсистем. Например:
    * `applyFilter(filterType)`: Этот метод принимает желаемый тип фильтра в качестве входных данных и внутренне вызывает соответствующий класс фильтра для его применения.
    * `resizeImage(width, height)`: Этот метод принимает новую ширину и высоту в качестве входных данных и внутренне вызывает класс функции изменения размера для изменения размера изображения.
    * `adjustBrightnessContrast(brightness, contrast)`: Этот метод принимает желаемые уровни яркости и контрастности в качестве входных данных и внутренне вызывает класс регулировки яркости/контрастности для изменения изображения.
    * `addTextOverlay(text, position)`: Этот метод принимает текст и его желаемое положение в качестве входных данных и внутренне вызывает класс текстового наложения для добавления текста на изображение.

**Преимущества:**

* **Упрощенный пользовательский интерфейс:** Класс Facade предоставляет более удобный интерфейс для взаимодействия со сложными функциями редактирования изображений.
* **Разделение:** Пользовательский код взаимодействует только с классом Facade, который скрывает сложность базовых подсистем.

# **Паттерн Легковес (Flyweight Pattern):**
## Упражнение
Представьте, что вы разрабатываете игру, в которой нужно отобразить большое количество деревьев леса. Каждый объект дерева может иметь такие атрибуты, как позиция, размер и цвет. Однако создание отдельного объекта для каждого дерева может быть ресурсоемким, особенно для густых лесов.

**Задача:** Разработать класс Flyweight для оптимизации использования памяти при отрисовке деревьев в игре.

**Решение:**

1. **Внутреннее vs Внешнее состояние:** Определите внутреннее состояние (неизменное) и внешнее состояние (изменяемое) объекта дерева. В данном случае внутренним состоянием может быть тип дерева (например, дуб, сосна) и его данные изображения. Внешним состоянием может быть положение и размер каждого отдельного экземпляра дерева.
2. **Класс Flyweight:** Создайте класс `Tree`, который выступает в роли Flyweight. Этот класс будет хранить внутреннее состояние (тип дерева и данные изображения).
3. **Фабрика:** Реализуйте класс `TreeFactory`, который управляет пулом заранее созданных объектов `Tree` с разными типами (дуб, сосна и т.д.). По запросу фабрика возвращает общий объект `Tree` нужного типа.
4. **Контекст (Внешнее состояние):** Храните внешнее состояние (позицию и размер) в отдельном классе или структуре данных, связанной с каждым экземпляром дерева в игровом мире.

**Преимущества:**

* **Оптимизация памяти:** Благодаря совместному использованию данных изображения дерева несколькими экземплярами, паттерн Flyweight снижает использование памяти для отрисовки большого количества деревьев.
* **Повышение производительности:** Общий доступ к данным объекта потенциально может улучшить производительность отрисовки за счет уменьшения накладных расходов на создание объектов.
